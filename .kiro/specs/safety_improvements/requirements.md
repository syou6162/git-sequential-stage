# 要件定義書

## 概要

本文書は、git-sequential-stageツールの安全性向上機能に関する要件を定義します。この機能は、意図しないコミット混入を防止し、Git操作エラーの適切な処理を提供することで、LLM Agentがツールを安全に使用できるようにします。

**重要な前提条件**: 本ツールの主要ユーザーはClaude CodeのようなLLM Agentです。LLM Agentは人間ほど柔軟ではなく、Git操作の再現性も低いため、以下の特性を考慮した設計が必要です：

- **機械的実行**: LLM Agentが確実に実行できる具体的なコマンド例の提供
- **明確な条件**: 事前条件・事後条件の明確な定義と検証
- **構造化メッセージ**: 解析しやすい一貫した形式のエラーメッセージ
- **再現性**: 同じ状況で同じ結果を保証する予測可能な動作

**ワークフロー統合**: 本機能は既存のsemantic_commitワークフローとの互換性を維持し、`git add -N`（intent-to-add）操作を適切にサポートします。

本要件は、[Issue #13](https://github.com/syou6162/git-sequential-stage/issues/13)で特定された3つの主要問題のうち、問題1（意図しないコミット混入）と問題2（Git操作エラー）の解決を目的としています。

### LLM Agent対応要件

本安全性機能はLLM Agentの特性に合わせた設計が必要です：

1. **機械実行可能性**: 全てのエラーメッセージに実行可能なコマンド例を含む
2. **構造化出力**: LLM Agentが解析しやすい一貫した形式のメッセージ
3. **予測可能性**: 同じ入力に対して同じ出力を保証する決定論的動作
4. **明確な状態遷移**: 事前条件・事後条件の機械的検証可能性

### ワークフロー統合要件

本安全性機能は以下の要件を満たす必要があります：

1. **Intent-to-add対応**: `git add -N`で追加されたファイルの適切な処理
2. **事前条件チェック**: ステージングエリアの状態確認
3. **事後状態保証**: 指定ハンクの正確なステージング
4. **既存ワークフロー保護**: semantic_commit.mdで定義されたプロセスの継続動作

## 要件

### 要件S1: ステージングエリア状態検出

**ユーザーストーリー:** LLM Agentとして、git-sequential-stageを実行する前にステージングエリアの状態を機械的に検出し、予測可能な条件判定を行いたい。

#### 受け入れ基準

1. **状態検出機能**:
   - ツール実行開始時、`git status --porcelain`でステージング済みファイルの詳細状態をチェックすること
   - ファイルタイプ別（M/A/D/R/C）に分類して表示すること
   - Intent-to-addファイル（`git add -N`）を通常のステージングと区別すること

2. **継続条件**:
   - ステージングエリアがクリーンな場合、通常の処理を継続すること
   - Intent-to-addファイルのみの場合、警告表示後に処理を継続すること

3. **停止条件**:
   - 通常のステージング済みファイルが存在する場合、エラーで停止すること
   - ファイルタイプ別の適切な対処法を提示すること

### 要件S2: Intent-to-addファイル統合

**ユーザーストーリー:** LLM Agentとして、semantic_commitワークフローで使用される`git add -N`（intent-to-add）ファイルを確実に識別し、決定論的な処理を実行したい。

#### 受け入れ基準

1. **Intent-to-addファイルの識別**:
   - `git add -N`で追加されたファイルを通常のステージングと区別すること
   - Intent-to-addファイル検出時は警告のみで処理を継続すること

2. **基本ワークフローサポート**:
   - Intent-to-addファイルのハンクを正常にステージングできること
   - 以下のワークフローが動作すること：
     ```bash
     git add -N new_file.py
     git diff HEAD > changes.patch
     git-sequential-stage -patch="changes.patch" -hunk="new_file.py:1,2"
     ```

3. **混在シナリオ対応**:
   - Intent-to-addファイルと通常ステージングが混在する場合
   - Intent-to-addは処理継続、通常ステージングはエラー停止

#### 統合エラーメッセージ形式（LLM Agent対応）

LLM Agentが機械的に解析・実行できる構造化形式を使用すること：

```
SAFETY_CHECK_FAILED: staging_area_not_clean

STAGED_FILES:
  MODIFIED: file1.py,file2.py
  NEW: new_file.py
  INTENT_TO_ADD: untracked_file.py
  DELETED: old_file.py
  RENAMED: old.py->new.py
  COPIED: original.py->copy.py

RECOMMENDED_ACTIONS:
  # For intent-to-add files - continue processing
  CONTINUE_PROCESSING: intent-to-add files detected (semantic_commit workflow)

  # For other files - execute in order
  STEP_1_DELETIONS: git commit -m "Remove old_file.py"
  STEP_2_RENAMES: git commit -m "Rename old.py to new.py"
  STEP_3_RESET_OTHERS: git reset HEAD file1.py file2.py new_file.py
  STEP_4_INTENT_TO_ADD: git add -N new_file.py
  STEP_5_SEMANTIC_COMMIT: # Use semantic_commit workflow

ALTERNATIVE_SIMPLE:
  COMMIT_ALL: git commit -m "Mixed changes"
  RESET_ALL: git reset HEAD

STATUS_CHECK: git status --porcelain
```

**LLM Agent向け設計原則**:
1. **構造化キーワード**: `SAFETY_CHECK_FAILED`, `STAGED_FILES`, `RECOMMENDED_ACTIONS`
2. **実行可能コマンド**: 全てのアクションに具体的なgitコマンドを提供
3. **順序付き手順**: `STEP_1`, `STEP_2`による明確な実行順序
4. **検証コマンド**: `STATUS_CHECK`による状態確認方法
5. **代替手段**: `ALTERNATIVE_SIMPLE`による簡単な選択肢

### 要件S3: ファイルタイプ別エラーメッセージ

**ユーザーストーリー:** LLM Agentとして、ステージング済みファイルのタイプに応じた機械実行可能なエラーメッセージと具体的なコマンド例を取得したい。

#### 受け入れ基準

1. **ファイルタイプ別メッセージ**:
   - 修正ファイル（M）: 「修正されたファイルがステージング済み」
   - 新規ファイル（A）: 「新規ファイルがステージング済み」
   - 削除ファイル（D）: 「ファイル削除がステージング済み」
   - リネームファイル（R）: 「ファイルリネームがステージング済み」
   - コピーファイル（C）: 「ファイルコピーがステージング済み」

2. **対処法の提示**:
   - 各ファイルタイプに適した推奨対処法を提示すること
   - 削除・リネームの場合は復旧の複雑性を警告すること
   - semantic_commitワークフローへの移行を推奨すること

3. **混在シナリオ対応**:
   - 複数タイプが混在する場合の段階的処理順序を提示すること
   - 削除・リネーム優先の処理順序を推奨すること

### 要件S4: Git操作エラーハンドリング

**ユーザーストーリー:** LLM Agentとして、ハンク適用時のGit操作エラーが構造化された形式で報告され、機械実行可能な復旧コマンドが提供されることを期待する。

#### 受け入れ基準

1. **新規ファイルエラー処理**:
   - "already exists in index"エラーの適切な捕捉と変換
   - 新規ファイル特有のエラーメッセージ表示

2. **削除ファイルエラー処理**:
   - "does not exist in index"エラーの適切な捕捉と変換
   - 削除ファイル特有のエラーメッセージ表示

3. **リネームファイルエラー処理**:
   - パッチID照合失敗の適切な処理
   - 新旧ファイル名での照合試行

4. **統一エラー形式**:
   - 技術的詳細と実用的解決策の両方を提供
   - 具体的なコマンド例を含む対処法の提示

5. **LLM Agent対応**:
   - 構造化キーワードによる機械解析可能な形式
   - 実行順序が明確な段階的コマンド提示
   - 状態検証用のコマンド例を含む

### 要件S5: Semantic Commitワークフローとの統合

**ユーザーストーリー:** 開発者として、semantic_commitワークフローでgit-sequential-stageを使用する際、intent-to-addファイルが適切に処理され、ハンクのステージングが正常に実行できることを期待する。

#### 受け入れ基準

1. **Intent-to-addファイルの処理**:
   - `git add -N new_file.py` 後にツールを実行できること
   - Intent-to-addファイルのハンクを正常にステージングできること
   - ステージング処理が完了すること

2. **基本ワークフローの動作保証**:
   - 以下のワークフローが正常に動作すること：
     ```bash
     # 1. Intent-to-addで新規ファイルを追加
     git add -N new_file.py

     # 2. パッチファイル生成
     git diff HEAD > changes.patch

     # 3. git-sequential-stageでハンク選択
     git-sequential-stage -patch="changes.patch" -hunk="new_file.py:1,2"
     ```

3. **混在シナリオでの動作**:
   - Intent-to-addファイルと通常の変更が混在する場合：
     - Intent-to-addファイルは警告のみで処理継続
     - 通常のステージング済みファイルはエラーで停止
     - ユーザーに明確な状況説明を提供

4. **エラーハンドリング**:
   - Intent-to-addファイルのハンク適用でエラーが発生した場合、適切なエラーメッセージを表示

5. **ログ出力**:
   - Intent-to-addファイル検出時の情報ログ

### 要件S6: ワークフロー非破壊保証

**ユーザーストーリー:** 開発者として、git-sequential-stageの安全性機能が既存のワークフローを破壊せず、適切な事前条件チェックと事後状態保証を提供することを期待する。

#### 受け入れ基準

1. **事前条件チェック**:
   - ステージングエリアの状態を正確に検出すること
   - Intent-to-addファイルを通常のステージングと区別すること
   - 各ファイルタイプ（M/A/D/R/C）を適切に分類すること

2. **事後状態保証**:
   - 指定されたハンクが正確にステージングされること
   - ステージング後の状態が予期可能であること
   - エラー発生時に部分的な変更を残さないこと

3. **ワークフロー継続性**:
   - Intent-to-addファイルの場合、処理を継続すること
   - 通常のステージング済みファイルの場合、適切にエラーで停止すること
   - ユーザーが次に取るべきアクションを明確に提示すること

4. **エラー時の状態保証**:
   - エラー発生時、Gitリポジトリの状態を破損させないこと
   - 部分的なステージングを残さないこと
   - ユーザーが復旧可能な状態を維持すること

### 要件S7: 正常ケースの動作保証

**ユーザーストーリー:** 開発者として、ステージングエリアがクリーンな状態でツールを実行した場合、指定されたハンクのみが正確にステージングされることを期待する。

#### 受け入れ基準

1. **クリーンなステージングエリアでの動作**:
   - 事前条件: ステージングエリアに何もファイルがない状態
   - 事後条件: 指定されたハンクのみがステージングされている状態
   - 指定されていないハンクはステージングされないこと

2. **差分がない場合の動作**:
   - 事前条件: ワーキングディレクトリに変更がない状態
   - 事後条件: ステージングエリアに何も追加されない状態
   - 正常終了（exit code 0）すること
   - 適切な情報メッセージを表示すること

3. **指定ハンクが存在しない場合の動作**:
   - 事前条件: パッチファイルに指定されたハンクが存在しない状態
   - 事後条件: ステージングエリアに変更がない状態
   - 適切なエラーメッセージを表示して終了すること

4. **部分ステージングの正確性**:
   - 事前条件: ファイルに複数のハンクが存在する状態
   - 事後条件: 指定されたハンクのみがステージングされている状態
   - 指定されていないハンクはワーキングディレクトリに残ること

5. **複数ファイル・複数ハンクの処理**:
   - 事前条件: 複数ファイルにわたる複数ハンクの指定
   - 事後条件: 指定されたすべてのハンクが正確にステージングされている状態
   - ファイル間での処理順序が適切であること

### 要件S8: エラーケースの動作保証

**ユーザーストーリー:** 開発者として、ツールがエラー状況を適切に検出し、予期可能な方法で処理することを期待する。

#### 受け入れ基準

1. **パッチファイルが存在しない場合**:
   - 事前条件: 指定されたパッチファイルが存在しない
   - 事後条件: ステージングエリアに変更がない状態
   - 適切なファイル不存在エラーを表示すること
   - 非ゼロの終了コードで終了すること

2. **パッチファイルが空の場合**:
   - 事前条件: パッチファイルが空または有効な差分を含まない
   - 事後条件: ステージングエリアに変更がない状態
   - 適切な情報メッセージを表示して正常終了（exit code 0）すること

3. **無効なハンク指定の場合**:
   - 事前条件: 存在しないファイルやハンク番号の指定
   - 事後条件: ステージングエリアに変更がない状態
   - 具体的なエラー内容を含むメッセージを表示すること
   - 非ゼロの終了コードで終了すること

4. **Git操作エラーの場合**:
   - 事前条件: git applyコマンドが失敗する状況
   - 事後条件: 部分的なステージングを残さない状態
   - エラーの原因と対処法を含むメッセージを表示すること
   - 非ゼロの終了コードで終了すること

5. **権限エラーの場合**:
   - 事前条件: ファイルやディレクトリへの書き込み権限がない
   - 事後条件: ステージングエリアに変更がない状態
   - 権限に関する適切なエラーメッセージを表示すること
   - 非ゼロの終了コードで終了すること

### 要件S9: 基本動作の一貫性

**ユーザーストーリー:** 開発者として、安全性機能が追加されても、正常なケースでは従来通りスムーズに動作することを期待する。

#### 受け入れ基準

1. **既存コマンドライン引数の互換性**:
   - `-patch` と `-hunk` フラグの動作が従来と同じであること
   - 複数の `-hunk` フラグの処理が従来と同じであること

2. **正常ケースでの出力一貫性**:
   - クリーンなステージングエリアでの実行時、従来と同じ結果を出力すること
   - 成功時の終了コードが 0 であること
   - エラー時の終了コードが非ゼロであること

3. **パフォーマンス要件**:
   - 安全性チェックにより実行時間が大幅に増加しないこと
   - 正常ケースでの処理時間が従来の120%以内であること

## 非機能要件

### パフォーマンス要件

1. ステージングエリアチェックは、100ms以内に完了すること
2. 新しい安全性チェックにより、全体の実行時間が20%以上増加しないこと
3. 大量のステージング済みファイル（100ファイル以上）でも、チェックが5秒以内に完了すること

### 信頼性要件

1. 安全性チェックの失敗により、既存のGitリポジトリ状態が破損しないこと
2. エラー発生時、システムは一貫した状態を維持すること
3. 並行実行時（複数のgit-sequential-stageプロセス）でも、安全性が保たれること

### 使いやすさ要件

1. エラーメッセージは、Git初心者でも理解できる平易な言葉で記述すること
2. 推奨対処法は、具体的なコマンド例を含むこと
3. 詳細ログは、問題の診断に必要な情報を含むこと

## テストシナリオ

### Semantic Commitワークフロー統合テスト

以下のシナリオを包括的にテストすること：

#### シナリオ1: 基本的なIntent-to-addワークフロー
```bash
# セットアップ
git init test_repo && cd test_repo
echo "print('hello')" > new_file.py

# Intent-to-add
git add -N new_file.py

# パッチ生成
git diff HEAD > changes.patch

# ツール実行（成功することを確認）
git-sequential-stage -patch="changes.patch" -hunk="new_file.py:1"

# コミット（成功することを確認）
git commit -m "feat: add new file"

# 検証: コミットが正常に作成されたことを確認
git log --oneline | head -1
```

#### シナリオ2: Intent-to-addと通常ステージングの混在
```bash
# セットアップ
echo "print('new')" > new_file.py
echo "updated" >> existing_file.py

# 混在状態作成
git add -N new_file.py          # Intent-to-add
git add existing_file.py        # 通常のステージング

# ツール実行（エラーになることを確認）
git-sequential-stage -patch="changes.patch" -hunk="new_file.py:1"

# 期待結果: 通常ステージングファイルによるエラー、Intent-to-addは警告のみ
```

#### シナリオ3: 複数Intent-to-addファイルの処理
```bash
# セットアップ
echo "file1 content" > file1.py
echo "file2 content" > file2.py

# 複数Intent-to-add
git add -N file1.py file2.py

# パッチ生成とツール実行
git diff HEAD > changes.patch
git-sequential-stage -patch="changes.patch" -hunk="file1.py:1" -hunk="file2.py:1"

# コミット成功を確認
git commit -m "feat: add multiple files"
```

#### シナリオ4: Intent-to-addファイルの部分ステージング
```bash
# セットアップ（複数ハンクを持つファイル）
cat > large_file.py << 'EOF'
def function1():
    print("function 1")

def function2():
    print("function 2")

def function3():
    print("function 3")
EOF

# Intent-to-add
git add -N large_file.py

# 部分ステージング
git diff HEAD > changes.patch
git-sequential-stage -patch="changes.patch" -hunk="large_file.py:1,3"

# コミット成功を確認
git commit -m "feat: add selected functions"

# 残りのハンクが存在することを確認
git diff HEAD --name-only | grep large_file.py
```

## 制約条件

1. 既存のgo-gitdiffライブラリとの互換性を維持すること
2. Gitコマンドの実行は、既存のCommandExecutorインターフェースを使用すること
3. テスト可能性を考慮し、依存性注入パターンを維持すること
4. 安全性を最優先とし、必要に応じて既存の動作を変更することを許可する
5. Semantic commitワークフローとの完全な互換性を維持すること
